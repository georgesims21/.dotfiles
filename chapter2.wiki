= Chapter 2 = 

_Mutual exclusions is perhaps the most prevalent form of coordination in multiprocessor programming._

== 2.1 Time ==

It is important to reason about complicated situations where multiple time intervale can overlap, or how they cannot.

*Threads share a common time*, but a thread is a _state machine_ and its state transitions are called events. These events are _instantaneous_, meaning they occur at a single instant in time.

The jth occurence of an event a_i is denoted by: 
	a_i_j

One event a preceeds another b such that:
	a -> b
meaning a happens at an earlier point in time than b. The precedence relation -> is a total order on events.

Lets say a_0 happens before a_1. An *interval* I_A = (a_0, a_1) precedes I_B = (b_0, b_1) written I_A -> I_B if a_1 -> b_0. In other words if a_1 comes before b_0 then I_A *preceded* I_B, or the *final* event in I_A comes before the *first* event of I_B.

(a,b) denotes the time interval between a and b on the same thread where a -> b.

Intervals which are not related by -> are said to be *concurrent*.

== 2.2 Critical sections ==

A *critical section* is a block of code which can only be executed by one thread at a time, or *mutual exclusion*. The best way for this is to use a lock to access it.

{{{java

public interface Lock {
	public void lock();
	public void unlock();
}

lock.lock();
try {
	... // critical section
} finally {
	lock.unlock();
	... // unlocking instructions
}

}}}

In the try/finally code, even if an exception was thrown within the try, the finally block of code will always execute and release the lock correctly.

When a thread aquires a lock, it *invalidates the its own working memory*, meaning all fields are re-read from memory.
When a thread releases a lock, the modified fields in working memory are written back to shared memory.

*Deadlock-free*: If a thread tries to aquire the lock, then some thread will succeed in aquiring it. This means if a thread calls lock() but never aquires it, then other threads must be completing an infinite number of critical regions.

*Starvation-free*: Every thread which tries to access the lock will eventually succeed. If some thread calls lock() then it will eventually aquire the lock.

*Mutual exclusion*: Critical sections of different threads do not overlap. Either CS_A_k -> CS_B_j OR CS_B_j -> CS_A_k.. never both at the same time.

== 2.3 2-Thread solutions ==

There are two lock methods which work when there are at most 2 threads concurrently.

*LockOne* uses the notion of flags to stop one thread entering the CS at the same time as the other. It does this by setting a shared flag array (with size 2 for the 2 threads) as true when it wants to enter the CS. The thread will then wait until the other flag's variable in the shared array is false before breaking the loop and entering the CS. *This algo satisfies mutual exclusion but doesn't work if the threads run concurrently, causing a deadlock*.

*LockTwo* uses a single shared variable called _victim_. This algo makes the first thread to require the lock give rights to the other thread to access the CS first. *This algo only works with concurrent threads, going at different times would lead to a deadlock.*

*Peterson lock* provides the best of both *Lockone* and *Locktwo* algos, using flags array and a victim variable (still for only two threads).

It is *mutually exclusive* because there are only two possibilities:
	1. j's flag is set to false. To enter, j must *first* set its flag to true and then the victim variable = j
	2. victim == j. This means j performed victim = j *after* i performed victim = i, thus also after i performed flag[i] = true

In either case, j must wait until i sets flag[i] = false or sets the victim variable to i.

*This means that j cannot enter it's critical section while i is in it's CS!*

It is *starvation-free* because say j is constantly entering it's critical section, starvation would occur if i couldn't access it's critical region. But the algorithm forces j to make victim = j after setting the flag, so it would be impossible for i to get starved as the victim is always changing when the lock is called.

== Volatile variables ==

When a *volatile variable* is read, its value is read from memory _not from the cache_. When it is written, it is done so straight back to memory.

*Out-of-order execution* by the hardware when dealing with a volitile variable *is not allowed*.

In the Peterson lock, the flag and victim variables must be volitile. Else stale values can be read from memory.

*A volatile array doesn not mean an array of volatile elements*.

== 2.4 Filter lock ==

The *filter* lock is a generalization of the Peterson lock with n >= 2 threads instead.

There are n-1 'waiting rooms' which are called *levels (L)*, ranging from 0 to n-1. At most, n-L threads can concurrently proceed to a level >= L.

	n threads		L = 0
	n-1 threads		L = 1
	n-2 threads		L = 2
	...
	2 threads		L = n-2
	1 thread		L = n-1

On each level up to n-1, there is a variable *victim*.
Say a thread A currently at level 1 wanted to move down to level 2. A will set level[A] = 2, and then instantly make itself the victim of that level, so victim[2]=A.
To actually move to level 2, A must first check that there is space on the next level by checking the value of level[j] for each j!=i making sure they are all less than 2. Then A must check the value of victim[2] to make sure it isn't the victim.

E.g:
	* Threads A,B,C are all at L=0
	* Thread B goes first
		* Sets level[B] = 1 and victim[1] = B
		* Because no other thread has a value in level >= 1, thread B proceeds to level 1
	* Thread C sets level[C] = 1 and victim[1] = C
	* Thread A sets level[A] = 1 and victim[1] = A
	* Thread C advances to level 1 because victim[1] != C
		* Thread C sets level[C] = 2 and victim[2] = C
	* Thread B sets level[B] = 2 and victim[2] = B
	* Thread C advances to level 2 (*Critical section*) because victim[2] != C
	* Thread C sets level[C] = 0 to return back to the first level
	* ...

*Mutual exclusion*:
	* Let L <= n-1
	* At most n-L threads can concurrently proceed to a level >= L
	* Either:
		* At most one thread is at level >= L
		* OR a thread is waiting at each level 0, ..., L-1
	* In both cases the claim holds
	* Taking L = n-1, only *one thread can be in its critical section*, thus providing mutual exclusion

*Starvation free*:
	* Consider a thread i waiting to go to a level L >= 1
	* If other threads keep on entering/leaving their critical sections, eventually a thread j!=i wants to enter level L and sets victim[L] = j
	* This leads to thread i proceeding to level L, *avoiding starvation*


The lock() method of the *filter lock* can be split into two parts:
	1. A *doorway* part (which completes in a finite number of steps)
	2. A *waiting* part (which can include spinning)

*Fairness*: If a thread i completes its doorway before another thread, then thread i should enter the critical section before j.

The *doorway* of the *filter lock* consists of the thread setting level[T] = L and victim[L] = T.

The doorway finishing in a finite number of steps is a *strong requirement*, and is called the *bounded wait-free progress property*.

== Bakery algorithm ==

*Provides mutual exclusion and is fair*.
To enter the critical section, a thread must set a flag and take a number greater than the numbers of all the other threads, like in a bakery queue. Once the other threads have been served, the thread can enter. Once it leaves the critical section its flag is reset.

*Problem*: Threads may concurrently take the same ticket number!
*Solution*: _Lexicographical order_:
	(L,i) < (m,j) if L < m, 
	OR
	L = m and i < j
{{{java

class Bakery implements Lock {
	boolean[] flag;
	Label[] label;
	public Bakery (int n) {
		flag = new boolean[n];
		label = new Label[n];
		for (int k = 0; k < n; k++) {
			flag[k] = false; label[k] = 0; 
		}
	}
	public void lock() { 
		int i = ThreadID.get();
	
	/* Start of doorway */
		flag[i] = true; // flag[A] indicates thread A wants to enter CR
		label[i] = max(label[0],...,label[n-1]) + 1; // label[A] is an int representing the threads order (ticket) for A. Searches for highest existing label and makes A max(label[]) + 1
	/* End of doorway */
	
		while âˆƒk (flag[k] && (label[k],k) < (label[i],i)) {};
		/* while some k exists that isn't i, if k has it's flag raised (true) AND
		  if k's label is less than i's.. or if they are equal, then if k < i make i wait */
	}
	public void unlock() { 
		int i = ThreadID.get();
		flag[i] = false; }
	}

}}}

*Problems:*
	* The number of threads is fixed beforehand
	* It requires n distinct variables for n threads (only read/write variables, cannot be avoided
E.g:
	* Two threads, A and B (0 and 1)
	* B: flag[B] = true
	* A: flag[A] = true
	* B: reads label[B]
	* A: reads label[A]
	* A: label[A] = 1
	* A: reads flag[B] == true
	* A: reads (label[B], 1) < (label[A], 0)
	* A: label[B] = 1
	* B: reads flag[A] == true
	* B: reads (label[A], 0) < (label[B], 1)
	* A: reads (label[A], 0) < (label[B], 1)
	* A: enters CS
	* A: exits CS

== Registers ==

_Shared memory locations are called registers_.

*Single-reader single-writer* (SRSW)
	- e.g. i and j in the Peterson lock algo

*Multi-reader single-writer* (MRSW)
	- e.g flag[] and label[] in the Bakery algo

*Multi-reader multi-writer* (MRMW)
	- e.g victim inthe Peterson lock
	
	
== 2.8 Lower bounds on the number of locations ==

The issue is, that at least n read/write ergisters are needed to solve deadlock-free mutual exclusion for n threads.
*Proof*: (for n = 2)
	* Given 2 threads, A and B and one MRMW register R.
	* Before either A or B enter their critical section, they must write to R
	* Let A and B both be in positions where they are about to write to R
	* They perform reads and may enter their critical sections
	* Let A write to R first, perform reads and then enter its critical section
	* The subequent write by B overwrites the value which was written to the register by A
	* *This means B can't tell that A is in its critical section*
	* B then performs reads and enters its critical section

With only n-1 registers two threads must share a register to signel to other threads that they have entered their critical sections. This is how the above proof _carriees over to general n_.

=== Fischer's algorithm ===

Say there are n threads A0, A1, ... , An-1
_turn_ is a MRMW register with range {-1, 0, ... , n-1} which is initially -1

    * A thread Ai which wants to enter its critical section _spins_ until turn is -1
    * *Within one time unit of this read* Ai sets the calue of turn to _i_
    * Ai *waits for more than ne time unit* and then reads what is in the turn register
    * If the value in there is still i, Ai can enter the critical section
    * Else Ai will spin on turn until the value in there is -1
    * When a thread exits its critical section, it sets the value of turn to -1

This algo provides *mutual exclusion* because if turn = -1 then no thread is in its critical section. Other threads can only concurrently set turn within one time unit of the first write. Due to the thread being forced to re-check the register once more after setting it, only the thread which wrote to turn *last* will enter the CS.

This algo is also *deadlock* free. Once a thread exits the CS, turn becomes -1 again. The last thread which sets turn within 1 time unit of the first write becomes *privileged*.

*Drawbacks:*
	* Not starvation free
	* If there is no contention, there is a needless delay
	* Requires a global clock for all threads to count the cycles
	* All of the threads must spin on the same single variable, turn
