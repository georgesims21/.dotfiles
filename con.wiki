 = Concurrency and Multithreading =
  
== Assignment ==
*DEADLINE(S)*: 
	* (*7 days*) 23rd Sep 23:59 - _For first round feedback_: Intermediate report and code (pre-improvement)
	* (*31 days*) 14th Oct 23:59 - _Final_ *strict* _deadline_: Final implementation and report
TODO
  [ ] - Refresh on (nested) depth first search algo
  [ ] - Read Courcoubetis
  [ ] - Read Schwoon
  	[ ] - Any obv problems stand out? Did either paper say why linearization is tough on it?
  [ ] - Analyze Laarman
  	[ ] - What are the difficulties in making this algorithm linearizable/concurrent?
	[ ] - How do you translate the algo into Java?
	[ ] - Answer the questions from the assignment PDF
  [ ] - Re-read the assignment PDF, does it all make sense? Make sure every aspect of it is clear
  --Coding-- (make this when above is complete)
  [ ] - List all possibilities for the translation, even ones which might not work. Can use these for fluff in the paper
  [ ] - *The implementation MUST exactly match the papers algorithm*
  
 [[assignment/assummary|Summary]]

== Book summaries ==
 
TODO
  [x] - Lecture 2: Theory
  [x] - Lecture 3: Theory
  [ ] - Lecture 4: Theory
  [ ] - Lecture 2: Exercises
  [ ] - Lecture 3: Exercises
  [ ] - Lecture 4: Exercises
  [ ] - Lecture 5: Theory
  [ ] - Lecture 5: Exercises
  
  * *Lecture 1* - *Intro:* _SMP & NUMA architectures, flag protocol(mutual exclusion), can protocol(producer-consumer), Amdahl's law, progress properties._
    - [[lecture1/Appendix A|Appendix A]]
    - [[lecture1/appendixb|Appendix B]]
    - [[lecture1/chapter1|Chapter 1]]
    - [[lecture1/chapter3|Chapter 3]]
    - [[lecture1/lec1sum|Summary]]
    - [[lecture1/exercises/exercises|Exercises]]
 		
  * *Lecture 2* - *Mutual exclusion:* _Critical sections, locks in Java, Peterson lock, Filter lock, volatile variables, Bakery algo, lower bound on the number of locations, Fischer's algo._
    - [[lecture2/chapter2|Chapter 2]]
    - [[lecture2/exercises/exercises|Exercises]]

  * *Lecture 3* - *Concurrent Objects:* _Pre and postconditions, linearizability, wait-free bounded queue, sequential consistency._ *Foundations of Shared Memory:* _From safe MRSW to atomic MRMW registers._
    - [[lecture3/lecnotes3|Lecture]]
    - [[lecture3/chapter3|Chapter 3]]
    - [[lecture3/chapter4|Chapter 4]]
    - [[lecture3/exercises/exercises|Exercises]]
  
  * *Lecture 4* - *The relative power of primitive synchronization operations:* _Consensus, impossibility of consensus with atomic registers, 2-thread consensus with a queue, impossibility of 3-thread consensus with a queue, read-modify-write registers, n-thread consensus with compareAndSet._ *Universality of consensus:* _A wait-free universal construction._
    - [[lecture4/lecnotes4|Lecture]]
    - [[lecture4/chapter5|Chapter 5]]
    - [[lecture4/exercises/exercises|Exrcises]]
